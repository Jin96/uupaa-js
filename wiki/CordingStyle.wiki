#summary JavaScript Cording Style Guide

<wiki:toc max_depth="2" />

uupaa.js は [http://webkit.org/coding/coding-style.html WebKit]のコーディングスタイルをベースにしています。

= 独自ルール =
以下は uupaa.js の独自ルールです。

== 語彙(ボキャブラリ) ==
以下の用語があります。

  * Mix はあらゆる型を意味します。
{{{
    function uuhash(key,     // @param Hash/String: key
                    value) { // @param Mix(= void): value

        ...
    }
}}}
  * void は undefined の別名です。
  * Hash は key/value ストアに特化した Object の別名です。データの入れ物として意識する場合に Hash と呼びます。
{{{
    var hash = { key: "value" };
}}}
  * !NodeList は document.getElementsByTagName() などが返す 動的な(liveな)ノードリストです。
  * !NodeArray は uu.tag(), uu.klass(), uu.query() などが返す 静的な(staticな)ノードの配列です。
  * Element は配列の要素を意味します。DOM Element は Node と呼び、配列の要素(Array Elements)とは区別します。
{{{
    var nodeList = document.getElementsByTagName("head"),
        node = nodeList[0],
        nodeArray = uu.tag("*"),
        element = [0, 1, 2][0];
}}}
  * !FakeArray は !NodeList や arguments などを総称する型です。!FakeArray は Array ではありませんが、 !FakeArray`[`indexer`]` でアクセスが可能で length プロパティを持ちます。uu.array(!FakeArray) で Array に変換できます。!FakeArray は Array Like とも呼ばれます。
{{{
    function() {

        var fakeArray1 = arguments, // Arguments型 かつ FakeArray型
            fakeArray2 = document.getElementByTagName("*"); // NodeList型 かつ FakeArray型
    }
}}}
  * !StringArray は文字列だけを要素に持つ配列です。 `[` "string", ... `]`
  * !NumberArray は数値だけを要素に持つ配列です。`[` 123, ... `]`
  * !IgnoreCaseString は大小文字を区別しない文字列です。
  * 上記以外にも多くの型が存在します。ほとんどのケースで 形容詞 + 基本型 + コレクション型の形をとっており、CSSSelectorExpressionString は CSSセレクタ式の文字列、TimerIDArray は幾つかの タイマーID を入れるための配列 となります。
{{{
    var stringArray = ["a", "b", "c"],
        numberArray = [0, 1, 2],
        callback = funtion() {},
        timerIDArray = [];

    timerIDArray.push(setTimeout(callback, 100));
    timerIDArray.push(setTimeout(callback, 200));
}}}

== 演算子の後ろで改行する ==
JavaScriptは行末のセミコロンを自動的に補完するため、
複数行に改行する際に、演算子を行の先頭に置くと思わぬバグを発生させるケースがあります。
これを回避するため、演算子や括弧の後ろで改行しセミコロンの補完を回避する必要があります。

{{{
    // good
    if (expression ||
        expression) {
        ...
    }

    // wrong
    if (expression
        || expression) {
        ...
    }

    // good
    return expression,
           expression;

    // bad
    return expression
           , expression;

    // good
    return {
        result: value
    };

    // bad
    return
    {
        result: value
    }

}}}


== if や for のブレス( {} )は省略禁止 ==
文法レベルでコードを短縮するのは Minifier の仕事です。
うかつに { } を省略すると、コードのメンテナンスでバグが入り込む余地を前もって提供する事になり、修正に対する耐久性が低い"ナイーブ"なコードになります。

ブレスを省略すると、狙ったポイントにブレークポイントも貼れなくなります。デバッグ効率も低下します。

{{{
    // good
    if (expression) {
        ...
    }

    // bad
    if (expression) ...

    // good
    for (;;) {
        ...
    }

    // bad
    for (;;) ...
}}}
Minifier は省略可能なブレスであれば、適切に省略したコードを生成してくれます。
ブレスの省略は低練度なソースコードの特徴の一つです。気をつけてください。


== function とブレス { をできるだけ同じ行に書く ==
function のブレス( { ) は、理由が無い限り function と同じ行に記述します。
また、function() { ... } とワンライナーで記述すると、狙ったポイントにブレークポイントが貼れなくなり、デバッグ効率も低下します。

{{{
    // good
    function() {

        ...
    }

    // wrong
    function()
    {
        ...
    }

    // wrong
    function() { ... }
}}}

== function() { の後ろで改行する ==
IE6 や IE7 のデバッグツールは、function() { の後に改行コードが存在しないとブレークポイントを貼れません。圧縮されたコードが IE6 や IE7 でデバッグできない(ブレークポイントが貼れない)のもこれが理由です。

{{{
    // good
    function() {

        var withCRLF; // 改行を一つ入れてから書き始める
    }

    // wrong
    function() {
        var noCRLF; // 改行なしで書き始める
    }
}}}

== 厳密比較演算子を使う ==
理由が無い限り、== ではなく === を使ってください。== は === に比べて実行速度が遅くなり、大抵のケースでデメリットがメリットを上回ります。

{{{
    // good
    if (a === b) {
        ...
    }

    // wrong
    if (a == b) {
        ...
    }
}}}


以下のようなケースでは == の利用も合法です。== を利用する場合はその理由をコメントで記述してください。コメントが無い == の利用は禁止します。
{{{
    // good, null または undefined かを調べる
    if (a == null) { // null or undefined
        ...
    }
    
    // bad
    if (a == null) {
        ...
    }
}}}

なお、ショートコードを目的とした == の利用も合法です。

== var はスコープ内に一つだけ ==
基本的に var はスコープ内に1つだけ設置できます。コードサイズや速度的な理由がある場合はもう1つだけ設置できます(最大で2つまで)。

場当たり的な変数宣言は低錬度なソースコードの特徴の一つです。工夫してください。
{{{
    // good
    function() {

        var nodeList, node, i = -1;
        
        nodeList = document.getElementByTagName("*");
        while ( (node = nodeList[++i]) ) {
            ...
        } 
    }

    // bad
    function() {

        var nodeList;

        nodeList = document.getElementByTagName("*");

        var i = 0;
        var length = nodeList.length;
       
        for (; i < length; i++) {
            var node = nodeList[i];
            
            ...
        }  
    }
}}}

== var の後ろには空行を置く ==
var の後ろには一つ以上の空行をおきます。
{{{
    // good
    var a = 1, b = 2, c;
 
    c = a * b;

    // bad
    var a = 1, b = 2, c;
    c = a * b;
}}}

== 状態をnode.classNameに保存しない ==
内部的な状態を node.className に保存することを禁止します。変数を使ってください。
{{{
     // good
     var hit = false;

     function eventHandler(evt) {

         if (evt.target === node) {
             hit = true;
         } else {
             hit = false;
         }
     }

     // bad
     function eventHandler(evt) {

         if (evt.target === node) {
             node.className += " hit ";
         } else {
             node.className = (" " + node.className + " ").replace(/ hit /, "");
         }
     }
}}}

== Strict Mode セーフにする ==
Strict Mode セーフなコードを記述してください。
行末のセミコロンの省略や arguments.callee の利用は、理由が無い限りそうすべきではありません。
{{{
    // bad
    var a = 3 * 200
}}}

== uu や data-uu で始まる識別子は予約語 ==
uu や data-uu で始まる識別子は uupaa.js の予約語です。